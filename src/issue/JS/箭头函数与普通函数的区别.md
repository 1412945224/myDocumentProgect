# 箭头函数和普通函数的区别

什么是箭头函数？

箭头函数是 ES6 推出的新的定义函数的方式！

```
    const fun = () => {}

```

有什么特点么？

使用箭头函数时如果只有一个参数， 那么小括号是可以省略的。

如果函数体内，只有一个表达式 那么可以省略大括号，且 return 关键字也可以省略，默认返回表达式执行后的结果。

```
 const fun = num => num + 1
```

## 箭头函数与普通函数中的 this 关键字

箭头函数中 this 是继承来的，而普通的函数的 this 是谁调用，就是谁 。

让我们来论证一下！

### 普通函数的 this

先试试用 window 调用

```
      function ordinary() {

        console.log(this);
      }

      window.ordinary(); // Window
```

好像是这样的，那么我们在用对象调用试试

```
      const obj = {

        a: "hello world",

        ordinary: function () {

          console.log(this);
        },
      };

      obj.ordinary(); // obj

```

结论： 普通函数确实如上面所说，谁调用 this 就是谁

### 箭头函数的 this

让我们看看箭头的 this 是什么吧

```
      const obj = {

        a: this,

        arrows: () => {

          console.log(this);

        },
        ordinary: function () {

          console.log(this.a); // window
        },
      };

      obj.arrows(); // window

      obj.ordinary(); // obj

```

结论 ：箭头函数是继承外层 this 的值，所以在箭头函数中 this 的值和外层作用域的 this 是一样的。

## 普通函数和箭头函数能修改它们的 this 指向么？

修改 this 指向的方法目前有三种 call、apply、bind。

我们用 call 来试一下。

### 普通函数修改 this 指向

```
      const a = "全局对象window";

      const obj = {

        a: "obj 对象",

        ordinary: function () {

          console.log(this.a);
        },
      };

      const copy = {

        a: "copy 对象",
      };

      obj.ordinary()  // obj 对象

      obj.ordinary.call(copy); // copy 对象
```

由此可以看出普通函数是可以改变 this 指向的

### 箭头函数修改 this 指向

```
      var a = "全局对象window";

      const obj = {

        a: "obj 对象",

        arrows: () => {

          console.log(this.a);

        },
      };

      const copy = {

        a: "copy 对象",

      };

      obj.arrows(); // 全局对象window

      obj.arrows.call(copy); // 全局对象window
```

从上面例子可以看出箭头函数是可以改变不了 this 指向的，

    思考 ：为啥这里要用 var 来声明全局变量 a ？ const 不行么？ 为什么？

结论 ：普通函数可以修改 this 指向，而箭头函数修改不了 this 指向。

## 箭头函数能作为构造函数使用么？

让我们来试试

```
      const Arrows = () => {};

      const ArrowsObj = new Arrows(); //Arrows is not a constructor
```

报错了，这条错误提示我们 Arrows 没有 constructor。

结论：箭头函数不能作为构造函数使用。

## 箭头函数有原型 prototype 么？

箭头函数不能作为构造函数来使用，这是为什么呢？ 是因为箭头函数的原型有问题么？

```

      const Ordinary = function () {};

      console.log(Ordinary.prototype); // {}

      const Arrows = () => {};

      console.log(Arrows.prototype); // undefined

```

原来箭头函数没有原型 prototype，这也就导致了箭头函数不能作为构造函数的原因了。

结论：箭头函数没有原型 prototype。

## 箭头函数有自己的 arguments 么？

arguments 是普通函数实参的集合

这是普通函数的

```
      const Ordinary = function () {

        console.log(arguments);

      };

      Ordinary(1, 2); // { "0": 1,   "1": 2}
```

看看箭头函数的

```
      const Arrows = () => {

        console.log(arguments);

      };

      Arrows(1, 2); // Uncaught ReferenceError: arguments is not defined at Arrows
```

报错了，看来我们已经得出结论了

结论：箭头函数没有自己的 arguments

## 箭头函数能用作 Generator 函数么，能使用 yeild 关键字么？

普通函数作为 Generator

```
      function* Ordinary() {

        yield 1;
        console.log("A");

        yield 2;
        console.log("B");

        yield 3;
        console.log("C");

        return 4;
      }

      // 定义迭代器对象
      const iterator = Ordinary();

      iterator.next(); // 执行 gen 函数，打印为空，遇到 yield 1 停止执行

      iterator.next(); // 继续执行函数，打印 A，遇到 yield 2 停止执行

      iterator.next(); // 继续执行函数，打印 B，遇到 yield 3 停止执行

      iterator.next(); // 继续执行函数，打印 C
```

箭头函数的没有这种用法
